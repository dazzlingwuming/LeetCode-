'''
给你一个整数数组 target 和一个数组 initial ，initial 数组与 target  数组有同样的维度，且一开始全部为 0 。

请你返回从 initial 得到  target 的最少操作次数，每次操作需遵循以下规则：

在 initial 中选择 任意 子数组，并将子数组中每个元素增加 1 。
答案保证在 32 位有符号整数以内。


示例 1：

输入：target = [1,2,3,2,1]
输出：3
解释：我们需要至少 3 次操作从 intial 数组得到 target 数组。
[0,0,0,0,0] 将下标为 0 到 4 的元素（包含二者）加 1 。
[1,1,1,1,1] 将下标为 1 到 3 的元素（包含二者）加 1 。
[1,2,2,2,1] 将下表为 2 的元素增加 1 。
[1,2,3,2,1] 得到了目标数组。
示例 2：

输入：target = [3,1,1,2]
输出：4
解释：(initial)[0,0,0,0] -> [1,1,1,1] -> [1,1,1,2] -> [2,1,1,2] -> [3,1,1,2] (target) 。
示例 3：

输入：target = [3,1,5,4,2]
输出：7
解释：(initial)[0,0,0,0,0] -> [1,1,1,1,1] -> [2,1,1,1,1] -> [3,1,1,1,1]
                                  -> [3,1,2,2,2] -> [3,1,3,3,2] -> [3,1,4,4,2] -> [3,1,5,4,2] (target)。
示例 4：

输入：target = [1,1,1,1]
输出：1
'''
from typing import List


class Solution:
    def minNumberOperations(self, target: List[int]) -> int:
        '''
        思路：其实这个可以反过来想，从target变成initial，每次操作选择一个子数组，将子数组中每个元素减少1，直到所有元素都变成0
        那么每次操作选择一个子数组，其实就是选择一个连续的非零子数组，将其全部减1
        这个复杂度比较高，可以优化为贪心，每次找到第一个非零元素开始，直到遇到0为止，这个区间就是一个子数组，操作次数加1，然后将这个区间的元素全部减1，重复这个过程直到所有元素都变成0
        '''
        '''
        每次操作（子数组减 1）的本质是覆盖一个连续区间。从左到右观察数组，当前元素与前一个元素的 “高度差” 决定了额外需要的操作次数：
        若当前元素 高于 前一个元素，高出的部分必须通过新的、仅覆盖当前及右侧区域的操作来实现（因为前一个元素已无法再参与减 1，否则会低于目标值）。
        若当前元素 低于或等于 前一个元素，其所需的操作可被前一个元素的操作覆盖，无需额外次数。
        计算方法：
        最少操作次数 = 第一个元素的值 + 所有 “当前元素 - 前一个元素” 的正数之和。
        '''
        for i in range(len(target)-1,0 ,-1):
            target[i] = max(0,target[i]-target[i-1])
        return sum(target)

if __name__ == "__main__":
    s = Solution()
    target = [1,2,3,2,1]
    print(s.minNumberOperations(target))













































